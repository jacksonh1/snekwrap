import os
import tempfile
from io import StringIO
from pathlib import Path

import numpy as np
import py3Dmol
from Bio import PDB
from Bio.Data import IUPACData
from Bio.PDB import PDBParser  # type: ignore
from Bio.PDB import PDBIO, MMCIFParser, PPBuilder  # type: ignore
from Bio.SeqIO.PdbIO import CifSeqresIterator
from Bio.SeqUtils import seq1
from IPython.display import display


def get_chains_from_structure(path):
    """
    This function borrowed/adapted from FragFold https://github.com/swanss/FragFold
    """
    path = Path(path)
    parser = PDBParser()
    structure = parser.get_structure(Path(path).stem, path)
    if structure is None:
        raise ValueError(f"Could not parse structure from {path}")
    chain_id_list = [c.id for c in structure.get_chains()]
    return chain_id_list


def extract_chain_sequence_from_resnames(input_file, chain_id="B"):
    file_extension = os.path.splitext(input_file)[1].lower()
    if file_extension == ".pdb":
        parser = PDBParser(QUIET=True)
    elif file_extension == ".cif":
        parser = MMCIFParser(QUIET=True)
    else:
        raise ValueError("Unsupported file format. Please use .pdb or .cif files.")
    structure = parser.get_structure("structure", input_file)
    for chain in structure.get_chains():  # type: ignore
        if chain.id == chain_id:
            # Extract residues and convert to one-letter code
            residues = [residue for residue in chain if residue.get_id()[0] == " "]
            sequence = "".join(seq1(residue.get_resname()) for residue in residues)
            return sequence
    raise ValueError(f"Chain {chain_id} not found in PDB file {input_file}")


def extract_sequences_from_pdb(input_file):
    file_extension = os.path.splitext(input_file)[1].lower()
    if file_extension == ".pdb":
        parser = PDBParser(QUIET=True)
    elif file_extension == ".cif":
        parser = MMCIFParser(QUIET=True)
    else:
        raise ValueError("Unsupported file format. Please use .pdb or .cif files.")
    structure = parser.get_structure("structure", input_file)
    ppb = PPBuilder()
    sequences = {}
    for pp in ppb.build_peptides(structure[0]):  # type: ignore
        chain_id = pp[0].get_parent().id
        sequences[chain_id] = str(pp.get_sequence())
    return sequences


def extract_chain_sequence_from_coords(input_file, chain_id="B"):
    file_extension = os.path.splitext(input_file)[1].lower()
    if file_extension == ".pdb":
        parser = PDBParser(QUIET=True)
    elif file_extension == ".cif":
        parser = MMCIFParser(QUIET=True)
    else:
        raise ValueError("Unsupported file format. Please use .pdb or .cif files.")

    structure = parser.get_structure(os.path.basename(input_file), input_file)
    ppb = PPBuilder()

    for model in structure:  # type: ignore
        for chain in model:
            if chain.id == chain_id:
                full_sequence = ""
                for pp in ppb.build_peptides(chain):
                    full_sequence += str(pp.get_sequence())
                return full_sequence
    return None


def _extract_chain_sequence_from_seqres_pdb(pdb_file, chain_id="A"):
    sequence = ""
    with open(pdb_file, "r") as file:
        for line in file:
            if line.startswith("SEQRES") and line[11] == chain_id:
                sequence += "".join(aa_three_to_one(aa) for aa in line[19:].split())
    if sequence == "":
        raise ValueError(f"Chain {chain_id} not found in {pdb_file}")
    return sequence


def _extract_chain_sequence_from_seqres_cif(cif_file, chain_id="A"):
    cif_sequences = {}
    with open(cif_file, "r") as handle:
        for record in CifSeqresIterator(handle):
            cif_sequences[record.annotations["chain"]] = str(record.seq)
    if chain_id not in cif_sequences:
        raise ValueError(f"Chain {chain_id} not found in {cif_file}")
    return cif_sequences[chain_id]


def extract_chain_sequence_from_seqres(input_file, chain_id="A"):
    file_extension = os.path.splitext(input_file)[1].lower()
    if file_extension == ".pdb":
        return _extract_chain_sequence_from_seqres_pdb(input_file, chain_id)
    elif file_extension == ".cif":
        return _extract_chain_sequence_from_seqres_cif(input_file, chain_id)
    else:
        raise ValueError("Unsupported file format. Please use .pdb or .cif files.")


def get_chain_center_of_mass(pdb_file, chain_id):
    """
    CAUTION: This was generated by an LLM and hasn't been tested.
    Calculate the center of mass of a specific chain in a PDB file.

    Parameters:
    - pdb_file: Path to the PDB file.
    - chain_id: ID of the chain for which to calculate the center of mass.

    Returns:
    - center_of_mass: A numpy array representing the center of mass coordinates.
    """
    parser = PDBParser(QUIET=True)
    structure = parser.get_structure("Structure", pdb_file)

    # Extract atoms from the specified chain
    chain_atoms = []
    for model in structure:  # type: ignore
        for chain in model:
            if chain.get_id() == chain_id:
                for residue in chain:
                    for atom in residue:
                        chain_atoms.append(atom)

    # Calculate the center of mass
    coords = np.array([atom.get_coord() for atom in chain_atoms])
    center_of_mass = np.mean(coords, axis=0)
    return [float(coord) for coord in center_of_mass]


def aa_three_to_one(aa):
    aa_dict = {
        "ALA": "A",
        "ARG": "R",
        "ASN": "N",
        "ASP": "D",
        "CYS": "C",
        "GLN": "Q",
        "GLU": "E",
        "GLY": "G",
        "HIS": "H",
        "ILE": "I",
        "LEU": "L",
        "LYS": "K",
        "MET": "M",
        "PHE": "F",
        "PRO": "P",
        "SER": "S",
        "THR": "T",
        "TRP": "W",
        "TYR": "Y",
        "VAL": "V",
    }
    return aa_dict.get(aa, "X")  # 'X' for unknown amino acids


def check_residue_numbering_with_pdb(pdb_file, residue, number, chain_id):
    parser = PDBParser(QUIET=True)
    structure = parser.get_structure("structure", pdb_file)
    for model in structure:
        for chain in model:
            if chain.id == chain_id:
                for res in chain:
                    if res.get_id()[1] == number:
                        resname = res.get_resname().capitalize()
                        if resname in IUPACData.protein_letters_3to1:
                            one_letter = IUPACData.protein_letters_3to1[resname]
                        else:
                            raise ValueError(f"Unknown residue name: {resname}")
                        if one_letter == residue:
                            return True
                        else:
                            raise ValueError(
                                f"Residue mismatch: expected {residue} ({number}), found {one_letter} ({res.get_id()[1]})"
                            )
    raise ValueError(
        f"Residue {residue} with number {number} not found in chain {chain_id} of the PDB file."
    )


def biopython_Structure_to_string(structure):
    """Convert a Biopython Structure object to a PDB string."""
    io = PDB.PDBIO()
    io.set_structure(structure)
    temp_file = tempfile.NamedTemporaryFile(mode="w", delete=False)
    io.save(temp_file.name)
    temp_file.close()
    with open(temp_file.name, "r") as f:
        pdb_string = f.read()
    os.remove(temp_file.name)  # Clean up the temporary file
    return pdb_string


def show_structure_with_py3Dmol(structure, style="cartoon"):
    """
    Displays a Biopython Structure object using py3Dmol in a Jupyter environment.
    """
    # Write structure to a PDB string
    pdb_buf = StringIO()
    io = PDBIO()
    io.set_structure(structure)
    io.save(pdb_buf)
    pdb_str = pdb_buf.getvalue()

    # Visualize with py3Dmol
    view = py3Dmol.view(width=600, height=400)
    view.addModel(pdb_str, "pdb")
    view.setStyle({style: {}})
    view.zoomTo()
    display(view)


def import_structure_biopython(pdb_file):
    pdb_file = Path(pdb_file)
    parser = PDB.PDBParser(QUIET=True)
    structure = parser.get_structure("protein", pdb_file)
    return structure


def assign_residues_to_new_chain(structure, chain_id, positions, new_chain_id="X"):
    """
    Extracts residues at the specified positions from the given chain in the PDB file
    and assigns them to a new chain with new_chain_id in the same structure.
    Removes the extracted residues from the original chain.
    Returns the modified structure object.
    
    Args:
        structure (Bio.PDB.Structure.Structure): Biopython Structure object.
        chain_id (str): Chain ID to extract from.
        positions (list of int): Residue positions (resseq numbers) to extract.
        new_chain_id (str): Chain ID for the new chain.
    Returns:
        structure (Bio.PDB.Structure.Structure): Modified structure with new chain.
    """
    for model in structure:
        # Find the source chain
        source_chain = None
        for chain in model:
            if chain.id == chain_id:
                source_chain = chain
                break
        if source_chain is None:
            raise ValueError(f"Chain {chain_id} not found in structure.")
        # Map resseq to residue
        resseq_to_residue = {residue.id[1]: residue for residue in source_chain if residue.id[0] == ' '}
        # Create new chain
        new_chain = PDB.Chain.Chain(new_chain_id)
        residues_to_remove = []
        for pos in positions:
            if pos in resseq_to_residue:
                residue = resseq_to_residue[pos]
                new_chain.add(residue.copy())
                residues_to_remove.append(residue)
            else:
                raise ValueError(f"Residue position {pos} not found in chain {chain_id}.")
        # Remove residues from original chain
        for residue in residues_to_remove:
            source_chain.detach_child(residue.id)
        model.add(new_chain)
        break  # Only modify the first model
    return structure


def remove_chain(structure, chain_id):
    for model in structure:
        chain_to_remove = None
        for chain in model:
            if chain.id == chain_id:
                chain_to_remove = chain
                break
        if chain_to_remove:
            model.detach_child(chain_to_remove.id)
    return structure


def save_structure_biopython(structure, output_path):
    io = PDBIO()
    io.set_structure(structure)
    io.save(str(output_path))
    return output_path


def slice_out_isolate_residues(pdb_file, chain_id=None, start_idx=1, end_idx=30):
    pdb_file = Path(pdb_file)
    parser = PDB.PDBParser(QUIET=True)
    structure = parser.get_structure("protein", pdb_file)
    io = PDBIO()
    for model in structure:
        for chain in model:
            if chain_id is not None and chain.id != chain_id:
                continue
            residues = []
            for residue in chain:
                if residue.id[0] == ' ':  # Standard amino acids only
                    if 'CA' in residue:
                        residues.append(residue)
            kmer_structure = PDB.Structure.Structure("kmer")
            kmer_model = PDB.Model.Model(0)
            kmer_chain = PDB.Chain.Chain(chain.id)
            for res_idx in range(start_idx, end_idx + 1):
                residue = residues[res_idx].copy()
                kmer_chain.add(residue)
            kmer_model.add(kmer_chain)
            kmer_structure.add(kmer_model)
            io.set_structure(kmer_structure)
            output_filename = f"{pdb_file.stem}_chain{chain.id}_res{start_idx}to{end_idx}.pdb"
            output_path = Path("./") / output_filename
            io.save(str(output_path))